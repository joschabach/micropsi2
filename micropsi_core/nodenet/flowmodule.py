

class FlowModule(object):
    """
    Flowmodule base class
    """

    @property
    def inputs(self):
        return self.definition['inputs']

    @property
    def outputs(self):
        return self.definition['outputs']

    @property
    def activation(self):
        return 1.0 if self.is_part_of_active_graph else 0.0

    @activation.setter
    def activation(self, activation):
        super(FlowModule, self.__class__).activation.fset(self, activation)

    def __init__(self, nodenet, inputmap={}, outputmap={}, is_copy_of=False, initialized=False, **kwargs):
        self.is_copy_of = is_copy_of
        super().__init__(nodenet, **kwargs)
        self.definition = nodenet.native_module_definitions[self.type]
        self.implementation = self.definition.get('implementation', 'python')
        self.outexpression = None
        self.outputmap = {}
        self.inputmap = {}
        self._load_functions()
        self.is_part_of_active_graph = False
        for i in self.definition['inputs']:
            self.inputmap[i] = tuple()
        for i in self.definition['outputs']:
            self.outputmap[i] = set()

        for name in inputmap:
            if name in self.inputmap:
                self.inputmap[name] = tuple(inputmap[name])
            else:
                self.logger.warning("Invalid flow-connection: Node %s has no input named %s" % (self, name))
        for name in outputmap:
            if name in self.outputmap:
                for link in outputmap[name]:
                    self.outputmap[name].add(tuple(link))
            else:
                self.logger.warning("Invalid flow-connection: Node %s has no output named %s" % (self, name))
        self.__initialized = initialized

    def get_data(self, *args, **kwargs):
        data = super().get_data(*args, **kwargs)
        data.update(self.get_flow_data())
        return data

    def get_flow_data(self, *args, **kwargs):
        inmap = {}
        outmap = {}
        data = {}
        for name in self.inputmap:
            inmap[name] = list(self.inputmap[name])
        for name in self.outputmap:
            outmap[name] = []
            for link in self.outputmap[name]:
                outmap[name].append(list(link))
        data = {
            'flow_module': True,
            'inputmap': inmap,
            'outputmap': outmap,
            'is_copy_of': self.is_copy_of,
            # 'initialized': self.__initialized
        }
        return data

    def is_output_connected(self):
        if len(self.outputs) == 0:
            return False
        else:
            return len(set.union(*list(self.outputmap.values()))) > 0

    def is_output_node(self):
        """ Returns true if this is an output-node (that is, if it has at least one link at its sub-slot)"""
        if self.definition.get('is_autogenerated'):
            return False
        return len(self.get_slot('sub').get_links()) > 0

    def is_input_node(self):
        """ Returns true if this is an input-node (that is, it either has no inputs, or datasources as inputs)"""
        if len(self.inputs) == 0:
            return True
        else:
            return ('worldadapter', 'datasources') in self.inputmap.values()

    def is_requested(self):
        """ Returns true if this node receives sub-activation"""
        if self.definition.get('is_autogenerated'):
            return False
        return self.get_slot('sub').activation

    def set_theta(self, name, val):
        """ Set the theta value of the given name """
        if self.is_copy_of:
            raise RuntimeError("Shallow copies can not set shared variables")
        self._nodenet.set_theta(self.uid, name, val)

    def get_theta(self, name):
        """ Get the theta value for the given name """
        if self.is_copy_of:
            return self._nodenet.get_theta(self.is_copy_of, name)
        return self._nodenet.get_theta(self.uid, name)

    def set_state(self, name, val):
        if self.is_copy_of:
            raise RuntimeError("Shallow copies can not set states")
        super().set_state(name, val)

    def get_state(self, name):
        if self.is_copy_of:
            return self._nodenet.get_node(self.is_copy_of).get_state(name)
        return super().get_state(name)

    def set_parameter(self, name, val):
        if self.is_copy_of:
            raise RuntimeError("Shallow copies can not set parameters")
        super().set_parameter(name, val)

    def get_parameter(self, name):
        if self.is_copy_of:
            return self._nodenet.get_node(self.is_copy_of).get_parameter(name)
        return super().get_parameter(name)

    def clone_parameters(self):
        if self.is_copy_of:
            return self._nodenet.get_node(self.is_copy_of).clone_parameters()
        return super().clone_parameters()

    def set_input(self, input_name, source_uid, source_output):
        """ Connect a Flowmodule or the worldadapter to the given input of this Flowmodule """
        if input_name not in self.inputs:
            raise NameError("Node %s has no input '%s'. Available inputs: %s" % (self, input_name, self.inputs))
        if self.inputmap.get(input_name):
            # hack: Worldadapter-flownodes can have multiple inputs
            if not self.definition.get('is_autogenerated'):
                raise RuntimeError("Input %s is already connected on node %s" % (input_name, self))
        self.inputmap[input_name] = (source_uid, source_output)

    def unset_input(self, input_name):
        """ Disconnect a Flowmodule or the worldadapter from the given input of this Flowmodule """
        if input_name not in self.inputs:
            raise NameError("Node %s has no input '%s'. Available inputs: %s" % (self, input_name, self.inputs))
        self.inputmap[input_name] = tuple()

    def set_output(self, output_name, target_uid, target_input):
        """ Connect a Flowmodule or the worldadapter to the given output of this Flowmodule """
        self.outputmap[output_name].add((target_uid, target_input))

    def unset_output(self, output_name, target_uid, target_input):
        """ Connect a Flowmodule or the worldadapter from the given output of this Flowmodule """
        self.outputmap[output_name].discard((target_uid, target_input))

    def node_function(self):
        """ activates the sur gate if this Flowmodule is part of an active graph """
        if not self.definition.get('is_autogenerated'):
            self.get_gate('sur').gate_function(1 if self.is_part_of_active_graph else 0)

    def ensure_initialized(self):
        if not self.__initialized and not self.is_copy_of:
            self._initfunction(self._nodenet.netapi, self, self.clone_parameters())
            self.__initialized = True

    def build(self, *inputs):
        """ Builds the node, calls the initfunction if needed, and returns an outexpression.
        This can be either a symbolic expression or a python function """
        if self.is_copy_of:
            self._nodenet.get_node(self.is_copy_of).ensure_initialized()
        self.ensure_initialized()
        if self.implementation == 'theano':
            from theano.tensor.var import TensorVariable
            outexpression = self._buildfunction(*inputs, netapi=self._nodenet.netapi, node=self, parameters=self.clone_parameters())

            # add names to the theano expressions returned by the build function.
            # names are added if we received a single expression OR exactly one per documented output,
            # but not for lists of expressions (which may have arbitrary many items).
            name_outexs = outexpression
            if len(self.outputs) == 1:
                name_outexs = [outexpression]
            for out_idx, subexpression in enumerate(name_outexs):
                if isinstance(subexpression, TensorVariable):
                    existing_name = "({})".format(subexpression.name) if subexpression.name is not None else ""
                    subexpression.name = "{}_{}{}".format(self.uid, self.outputs[out_idx], existing_name)

        elif self.implementation == 'python':
            outexpression = self._flowfunction

        else:
            raise ValueError("Unknown flow-implementation: %s" % self.implementation)

        self.outexpression = outexpression

        return outexpression

    def _load_functions(self):
        """ Loads the run-/build-/init-functions """
        import os
        import inspect
        from importlib.machinery import SourceFileLoader
        if self.definition.get('is_tensorrt_engine'):
            self.__initialized = False
            self._initfunction = self.tensorrt_init
            self._flowfunction = self.tensorrt_run
            self.engine_file = self.definition['path']
        elif self.definition.get('is_autogenerated'):
            self.__initialized = True
            self._initfunction = lambda x, y, z: None
            self._flowfunction = self.worldadapter_flowfunction
        else:
            sourcefile = self.definition['path']
            modulename = 'nodetypes.' + self.definition['category'].replace('/', '.') + os.path.basename(sourcefile)[:-3]
            module = SourceFileLoader(modulename, sourcefile).load_module()

            if self.definition.get('init_function_name'):
                self._initfunction = getattr(module, self.definition['init_function_name'])
                self.__initialized = False
            else:
                self._initfunction = lambda x, y, z: None
                self.__initialized = True

            if self.implementation == 'python':
                self._flowfunction = getattr(module, self.definition['run_function_name'])
                self.line_number = inspect.getsourcelines(self._flowfunction)[1]
            else:
                self._buildfunction = getattr(module, self.definition['build_function_name'])
                self.line_number = inspect.getsourcelines(self._buildfunction)[1]

    def worldadapter_flowfunction(self, *args, **kwargs):
        if len(self.outputs) == 1:
            returnvalue = self._nodenet.worldadapter_instance.get_flow_datasource(self.outputs[0])
        else:
            returnvalue = []
            for key in self.outputs:
                returnvalue.append(self._nodenet.worldadapter_instance.get_flow_datasource(key))
            returnvalue = tuple(returnvalue)
        return returnvalue

    def tensorrt_init(self, *args, **kwargs):
        from tensorrt.lite import Engine
        import pycuda.driver as cuda
        cuda.init()
        args[1].cuda_context = cuda.Device(0).make_context()
        args[0].logger.info('Loading TensorRT engine: %s' % self.engine_file)
        args[1].trt_engine = Engine(PLAN=self.engine_file)
        cuda.Context.pop()

    def tensorrt_run(self, *args, **kwargs):
        import pycuda.driver as cuda
        args[2].cuda_context.push()
        output = args[2].trt_engine.infer(args[0])[0]
        cuda.Context.pop()
        return output
